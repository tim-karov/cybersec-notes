# HTB: "Writeup" Machine Walkthrough

- **Difficulty:** Easy
- **Дата:** 17.01.2026
- **Цель:** Практика

## 1. Recon & Enumeration
Nmap `nmap -sC -sV -v $ip`, получаем 2 открытых порта `22 (SSH)`, `80 (HTTP)`. Nmap также подсветил нам некую директорию `/writeup`. Видим, что это персональный сайт, на котором автор пишет про прохождение машин на площадках. Сайт абсолютно без какого-либо оформления и дополнительной информации. Зайдя в исходный код страницы, нахожу, что сайт работает на `CMS Made Simple - Copyright (C) 2004-2019. All rights reserved.`. Об версии данной CMS информации нет, чтож, идем в Google.

Предположив, что сайт работает на последней версии 2019 года (v 2.2.8), находим [CVE-2019–9053](https://nvd.nist.gov/vuln/detail/CVE-2019-9053), в которой говорится, что с помощью специально сформированного URL-адреса можно осуществить неаутентифицированную слепую SQL-инъекцию по времени через параметр m1_idlist.

Кстати, для любителей метода перечислений и грубой силы, спешу вас расстроить, на этой машине этого сделать не получится, так как она оснащёна защитой от DoS-атак, предотвращающей перебор паролей. Я сам на эти грабли наступил.

## 2. Exploitation
На ExploitDB нашел подходящий [эксплойт](https://www.exploit-db.com/exploits/46635), который у меня никак не хотел запускаться, постоянно появлялись какие-то новые ошибки, тут я принял стратегическое решение переписать старый эксплойт под python3, найти который мы можете у меня в профиле — [cmsms-sqli](https://github.com/tim-karov/cmsms-sqli). Инструкция, как им пользоваться тоже идет в комплекте. Отработав, мы получаем следующий вывод:
```bash
Username: jkr
MD5: 62def4866937f08cc13bab43bb14e6f7
crack: hashcat -a 0 -m 20 '62def4866937f08cc13bab43bb14e6f7:5a599ef579066807' rockyou.txt
```
И так, эксплойт отработал что мы имеем на выходе? Мы имеем username, cоль и хеш пароля. Пробуем с помощью инструмента hashcat, и по готовой подсказке эксплойта, получиить пароль из хеша:
```bash
hashcat -a 0 -m 20 '62def4866937f08cc13bab43bb14e6f7:5a599ef579066807' rockyou.txt
```
Hashcat отработал, пароль получен, в итоге имеем креды: `jkr:raykayjay9`.

Nmap подсвеитл нам откртый `22 (SSH)`, подключаемся — успех! `find / -name "user.txt" 2>/dev/null` user-флаг в кармане, давайте поднимать привилегии.

## 3. Privilege Escalation
Вот тут было очень туго. LinPEAS сразу дал вектор повышения привилегий — `Writable PATH abuses`, и сразу указал на пути: `/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games`. На [hacktricks](https://book.hacktricks.wiki/en/linux-hardening/privilege-escalation/index.html#writable-path-abuses) находим:

> Если вы обнаружите, что можете записывать данные в какую-либо папку из $PATH, вы можете попытаться повысить свои привилегии, создав бэкдор внутри папки с правами записи , используя имя команды, которая будет выполняться другим пользователем (в идеале root) и которая не загружается из папки, расположенной перед вашей папкой с правами записи в $PATH.

Окей, раз LinPEAS подсвечивал путь `/usr/local/bin`, проверим, можем ли мы туда писать что-то: `ls -ld /usr/local/bin`, окей, можем. Где-то тут я оканчательно запутался.

Окей(2). Вижу, что я в группе `staff`, нестандартная история. `echo $PATH` — `/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games`. Тут пока единственный вывод — writable директория в PATH + нестандартная группа. Я все проверил, но нигде нет каких-либо зацепок. Руки опустились, я полез смотреть walktrough на YT у ippsec'а, мне нужна была хоть какая-то маленькая крупица, подсказка, и ответ я нашел в тулзе [pspy](https://github.com/DominicBreuker/pspy), с помощью которой можно было посмотреть за процессами без необходимости прав root. Pspy позволяет видеть команды, выполняемые другими пользователями, задания cron и т. д., в процессе их выполнения.

Загрузив ее на тачку жертвы, запустив, чего-то особенного не заметил, может быть root что-то делает при моём логине? Вторым терминалом логинюсь по SSH, и лювлю строку: `sh -c /usr/bin/env -i PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin run-parts --lsbsysinit /etc/update-motd.d > /run/motd.dynamic.new`. Окей, root выполняет run-parts, который ищется по PATH. PATH начинается с директорий, в которые я могу писать. Значит, если я положу /usr/local/bin/run-parts, root возьмёт мой бинарник.

Создаём фейковый run-parts в /usr/local/bin, который выполняется вместо настоящего как root при SSH-логине:
```bash
echo -e '#!/bin/bash\ncp /bin/bash /tmp/rootbash\nchmod +s /tmp/rootbash' > /usr/local/bin/run-parts
chmod +x /usr/local/bin/run-parts
```
Давайте разберем этот однострочник на более понятные, составные части, что он делает?
  - `cp /bin/bash /tmp/rootbash` — копирует обычный /bin/bash в /tmp/rootbash
  - `chmod +s` — ставит SUID-бит (-rwsr-xr-x root root). SUID заставляет файл выполняться от root, независимо от того, кто его запускает.
  - `> /usr/local/bin/run-parts` — перенаправляет вывод echo в файл /usr/local/bin/run-parts.

Последнее что нам остается — `/tmp/rootbash -p`, и ура, мы root, забираем root-флаг!

## Done
Фуф, до момента повышения привилегий было вообще все супер-изи, даже было время, чтобы воскресить, давно устаревший, эксплойт, написанный еще на python2. А вот с privesc этапом пришлось повозиться, наверное, не подсмотрев немного прохождение ippsec'a, я бы сдался.
